# Проектная работа "Веб-ларек"

Стек: HTML, SCSS, TS, Webpack

Структура проекта:
- src/ — исходные файлы проекта
- src/components/ — папка с JS компонентами
- src/components/base/ — папка с базовым кодом

Важные файлы:
- src/pages/index.html — HTML-файл главной страницы
- src/types/index.ts — файл с типами
- src/index.ts — точка входа приложения
- src/scss/styles.scss — корневой файл стилей
- src/utils/constants.ts — файл с константами
- src/utils/utils.ts — файл с утилитами

## Установка и запуск
Для установки и запуска проекта необходимо выполнить команды

```
npm install
npm run start
```

или

```
yarn
yarn start
```
## Сборка

```
npm run build
```

или

```
yarn build
```

## Обзор базового кода 

#### Класс Api

базовый класс, общая реализация, на его основе будет создан собственный, под конкретную реализацию текущего проекта.

readonly base с типом строка, содержит в себе базовую ссылку для коммуникации с сервером
protected options с типом RequestInit, конфигурация запроса на сервером

конструктор принимает baseUrl и options (может быть пустым объектом)

методы:
get(uri тип строка) не имеет возвратного значения, добавляет uri к baseUrl, для обращения за объектами на сервер
post(uri тип строка, data тип объект, method тип ApiPostMethods (значение по умолчанию POST))
handleResponse(response типа Response) возвращает объект Promise, служит для обработки ответов сервера в случае успеха парсим данные, в случае провала парсим JSON ошибки

#### Класс Component 

абстрактный родительский класс для всех объектов слоя отображения

конструктор принимает container тип HTMLElement, сюда передаем контейнер в котором будем искать другие элементы для выгрузки данных из модели

методы для работы с разметкой:

toggleClass , без возвратного значения, принимает в параметрах элемент разметки, название класса которое нужно переключать, и один необзятальный паратметр force тип булевый для ручного переключения (установки) класса. true - установит, false - удалит. Если не передан класс будет переключаться. 

setText принимет в параметры элемент разметки и значение. Внутри в элемент разметки устанавливается текстовое содержимое из параметра значения. К примеру приходят данные из модели. Берем элемент разметки и в текстовое поле устанавливаем данные из модели. Без возвратного значения

setDisabled, метод для управления состоянием disabled у HTML элементов. Без возвратного значения. Принимает в параметрах вызова элемент разметки, состоянием которого нужно управлять. и булевый параметр state, если передано значение true - элемент получит парамтер disabled и false в этом случае получит состояние активный. 

setHidden метод без возвратного значения, в параметрах вызова получает элемент разметки, у которого управляем значением отображения. Скрываем из интерфейса

setVisible метод без возвратного значения, в параметрах получаем элемент разметки отображением которго управляем. Делаем элемент видимым

setImage метоб без возвратного значения, в параметры получает элемент разметки тип HTMLImageElement, параметр src это ссылка на изображение и необязательный параметр alt для установки альтернативного текста для изображения. 

render

## Типизация данных в приложении

В приложение с сервера поступают данные, объекты товаров, это будут объекты типа ICard.
#### interface ICard {
  id: string - каждый товар приходит с уникальным id, тип строка 
  category: string - товары имеют разные категории, тип строка
  title: string - у товаров разные названия, поле для названия, тип строка
  image: string - хранит ссылку на изображение товара, тип строка
  description: string - поле для полного описания товара, тип строка
  price: number | null - для хранения цены на товар, некоторые товары могут быть бесценными, тип число либо null
}

Товары можно положить в корзину, данные не приходят с сервера, но их надо хранить в приложении, типизация объекта для хранения товаров
#### interface IBasket {
  items: ICard[]; - в корзину можно передать товары, тип массив объектов-ICard
  total: number - поле для хранения общей стоимости товаров в корзине
}

Пользователь может выбрать способ оплаты товаров, это либо офлайн, либо онлайн оплата
#### type Tpayment =
'cash' - тип для обозначения оплаты при получении
'card' - тип оплаты для онлайн

Как итог, приложение должно отправить на сервер объект, который будет содержать в себе информацию по заказу:
#### interface IOrder {
  payment: Tpayment - поле для обозначения выбранного типа оплаты, тип Tpayment
  address: string - адрес доставки заказа, тип строка
  email: string - клиентская почта, тип строка
  phone: string - пользовательский номер телефона, тип строка
  items: string[] - на сервер достаточно передеать только id товаров, тип массив строк
  total: number - подсчет общей суммы товаров, тип число
}

В приложении будет один объект, который будет содержать все данные, объект состояние приложения, одно из полей будет заказ, без поля общей суммы и объектов для заказа
#### type TOrder {
  payment: Tpayment;
  address: string;
  email: string;
  phone: string;
}

В приложении будет две формы, первая часть типизирует только тип оплаты и адрес
#### type TOrderForm = Pick<IOrder, 'payment'|'address'>;

Вторая часть типизация почты и номера телефона 
#### type TContactsForm = Pick<IOrder, 'email'|'phone'>;

После отправки заказа на сервер приходит ответ в виде объекта
#### interface IOrderResult {
  id: string;    - каждый заказ получает id сохраняем id в данное поле
  total: number; - отображение суммы отправленого заказа
}

Общий объект для состояния приложения. Отвечает за хранение данные, в каталоге, в корзине, в заказе
#### interface AppData {
  praview: ICard    - тип ICard, содержит объект для отображения его данных в модальном окне
  catalog: ICard[]; – тип ICard[], после получения ответа с сервера, товары сохраняем в поле этого объекта
  basket: IBasket;  - типа IBasket, поле для хранения товаров, добавленных в коризну, подсчет суммы
  order: IOrder;    - тип IOrder, поле для хранения объекта заказа отправляемого на сервер
}

## Слой данных

## Слой отображения

#### class Page

#### class Basket 

#### class Card

## События в приложении

`items:updated` – при старте приложения в экз класса слоя коммуникации с сервера поступают данные, устанавливаются в поле `_catalog` экз класса AppData \
`basket:open` – на главной странице пользовательского интерефейса, при клике на иконку корзины, генерируется событие, для открытия модального окна \
`card:select` – после загрузки, в каталоге, на главной странице посетитель может кликнуть на заинтересовавший товар, сгенерируется это событие, оно нужно для установки значения в поле `_preview` экз класс AppData, для последующего открытия данного товара в модальном окне, с полным описанием. С возможностью добавить его в корзину \
`preview:updated` – генерируется при изменениях в поле _preview экз класс AppData \
`modal:open` – событие для реализации открытия модального окна
`modal:close` – событие для реализации закрытия модального окна